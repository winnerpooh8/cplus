//#include <iostream>
//using namespace std;
////함수 복습
//
////함수의 기본 형태 
//
////반환타입 함수명(매개변수)
////{
//// 함수 호출시 실행 할 명령문 
////}
//
////1. return값이 존재하는 함수
////반환타입 함수명()
////{
//// return반환타입에 맞는 값;
//// }
////ex) 반환타입이 int라면 return값도 int 형태의 값
//
////2. return값이 존재하지 않는 함수(void)
////void함수명()
////{
//// 함수 호출시 실행 할 명령문 
////}
//
////함수 호출방법
////함수명();
//
////return의 기능
////1. 함수를 종료하고, 함수를 호출한 위치로 이동시킵니다.(return이 없는 경우라면 함수의 명령이 끝나면 자동으로 종료)
////2. return 다음에 값이 작성된다면, 함수를 호출한 위치에 해당 값을 전달합니다.
////3. c/c++의 return 값은 1개만 전달이 가능합니다.
//
////함수의 인수, 매개변수
////1. 인수, 인자값(Argument) : 함수 호출 시 넣어줄 값
//
////2. 매개변수(Parameter) : 함수의 도입부 () 부분 작성될 함수 호출 시 전달받을 데이터에 대한 표현
////사용 예시)
////int sum(int a,int b); <- 정수형 데이터 2개를 요구하는 함수 sum
////int func(void); <- 매개변수에 void가 적혀있다면, 매개변수가 필요없음을 명시합니다.
//
////변수의 범위(Scope)
////1. 전역변수 : 함수 외부에서 선언된 변수
////             1. 프로그램 내에 함수에서도 사용이 가능합니다.
////             2. 프로그램 실행 중에 메모리 상에 계속 존재합니다.
////             3. 특정 함수가 전역변수의 값을 수정할 경우, 다른 함수에서 출력할 때 수정된 값이 나오게 됩니다.
////             4. 별도로 초기화를 안할 경우 데이터 초기 값으로 자동 설정됩니다.(정수형 데이터0) 
////2. 지역변수 : 함수 내부에서 선언된 변수
////             1. 변수가 선언된 함수 내에서만 사용이 가능합니다.
////             2. 지역변수는 함수의 호출시 생성되며 종료시 삭제됩니다.
////             3. 함수의 매개변수 또한, 일종의 지역 변수입니다.(함수 호출 시 값을 받고, 변수로 사용되며 종료시 삭제되기 때문)
//
//
////3. 정적변수(Static) : 프로그램이 종료되기 전까지 소멸하지 않는 변수
////             1. static키워즈가 붙은 변수를 의미합니다. ex)static int count;
////             2. 정적 변수의 초기화는 1번만 진행합니다.
////             3. 초기화하는 값은 반드시 상수여야 합니다.
////             4. 함수 내에서 만들어도, 해당 변수는 사라지지 않고 유지됩니다.(정적 지역 변수:static local)
////             5. 함수의 매개 변수로 사용할 수 없습니다.
////             6. 변수의 범위가 파일 범위로 제한됩니다.(외부의 코드로 활용이 불가능 : 정적 전역 변수 : static global)
//
////메모리 영역
////프로그램에서는 변수,함수 등을 저장하는 메모리 영역이 존재합니다.
////영역 별로 저장되는 데이터들은 다음과 같습니다.
//
//// === COMPILE ===
//
////1. Code 영역
//// --> 함수, 제어문, 상수 등 코드가 저장되는 영역(실행할 프로그램의 코드가 저장되는 영역, 텍스트 영역이라고도 부릅니다.)
////     CPU는 코드 영역에 저장되어 있는 명령 하나하나를 가져와서 처리합니다.
////     프로그램이 시작하고 종료하는 순간까지 메모리에 남아있게 됩니다.
//
////2. Data 영역
////--> 프로그램의 전역 변수와 정적 변수가 저장되는 영역입니다.
////    프로그램 시작시 할당되면서, 프로그램이 종료되면 소멸합니다.
//
////3. BSS 영역
//// --> Data 영역에 있는 변수 중에서 초기 값이 없는 전역 변수나 배열, 정적 변수가 저장되는 영역
//
////=== RUNTIME ===
//
////4. Heap 영역
//// --> 프로그래머가 직접 메모리를 할당하고 해제하는 영역(동적할당)
//// C언어에서는 malloc()을 통해 할당을 작업하며,C++에서는 new를 통해 할당을 작업합니다.
//// C언어에서는 free()를 통해 할당을 해제하며, C++에서는 delete를 통해 할당을 해제합니다.
//// 선입선출(First-In, First-Out : FIFO)로 먼저 들어온 데이터가 먼저 빠져나가게 되는 방식
//// --> 낮은 주소(위)로부터 높은 주소(아래) 방향으로 데이터가 쌓이는 형태
//
////5. Stack영역
////--> 프로그램이 자동으로 사용하는 임시 메모리 영역
//// 함수 호출 시 생성되는 지역 변수나 매개 변수가 저장되는 영역으로, 함수의 호출이 완료되면 해당 데이터는 사라집니다.
//// 스택 영역에 저장되는 함수의 호출 정보를 스택 프레임(stack frame)이라고 부릅니다.
//// Stack의 호출에는 리미트가 걸려있고, 일반적인 프로그램은 특정 횟수를 넘을 경우 더이상 호출 되지 않도록 막습니다.(Stack overflow 현상 방지)
//// 후입선출(Last-In, Last-Out : LIFO)로 나중에 들어온 데이터가 먼저 빠져나가게 되는 방식
//// --> 높은 주소(아래)로부터 낮은 주소(위)로 데이터가 쌓이는 형태
//
//// 오버플로(Overflow):한정되어 있는 메모리 공간이 부족해 메모리 안에 있는 데이터가 넘쳐 흐르는 현상
//// 문제되는 이유: 데이터가 넘치면 상대 공간을 침범하는 일이 발생할 수 있고, 이는 데이터를 제대로 불러올 수 없는 상황까지 이어집니다.
//
//
//
//
//
////전역변수
//int a = 5;
//
////지역변수
//void GlobalF()
//{
//	a++;
//	cout << "(Global)" << a << endl;
//}
//void localF()
//{
//	int a = 10;
//	a++;
//	cout << "(local)" << a << endl;
//}
//void ParameterF(int a)
//{
//	a = 20; 
//	a++;
//	cout << "(Parameter)" << a << endl;
//}
//void staticF()
//{
//	static int a = 1;
//	a++;
//	cout << "(static)" << a << endl;
//}
//
//
//
//
//int main()
//{
//	cout << "(main/global)" << a << endl;
//	GlobalF();
//	cout << "(main/global)" << a << endl;
//	int a = 10; //전역 변수가 a가 있는 상태에서 지역변수 a가 새로 만들어진다면, 함수 내에서는 지역변수를 우선 처리합니다.
//	cout << "(main/local)" << a << endl;
//	GlobalF();
//	cout << "(main/local)" << a << endl;//현 시점에서 main의 a는 지역변수이기 때문에 GlobalF에 의해 전역변수 a의 값이 올라도,main의 a랑은 전혀 상관 없는 갑이 됩니다.
//
//	ParameterF(a);
//	cout << "(main/local)" << a << endl;//매개변수로 a의 "값"을 전달합니다. 그리고 ParameterF에서 그 값을 기반으로 매개변수 a를 할당합니다.
//	                                    //그 매개변수 a와 main의 지역변수 a의 서로 다른 데이터 입니다.
//	                                    //call by value(값에 의한 호출)이라고 부르며,함수가 종료되도 변경된 내용이 적용되지 않습니다.
//	                                    //해결방안 : call by reference(참조에 의한 전달) : 매개변수 를 포인터로 받거나, 참조자로 받으면 전달 가능
//	
//	staticF();
//	cout << "(main/local)" << a << endl;
//
//	cout << "(5번연속출력)" << a << endl;
//	//5번 연속 출력 확인해 보는 각 함수의 특징
//	for (int i = 0; i < 5; i++)
//	{
//		GlobalF();
//		localF();
//		ParameterF(a);
//		staticF();
//		cout << "==========" << endl;
//		cout << "작업종료" << a << endl;
//	}
//
//
//
//	return 0;
//}